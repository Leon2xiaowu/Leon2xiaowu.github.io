<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> ES6学习笔记-Set和Map数据结构 | 普通程序员的博客</title>
<link rel="shortcut icon" href="https://Leon2xiaowu.github.io/favicon.ico?v=1560867619738">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://Leon2xiaowu.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Leon2xiaowu.github.io">
  <img class="avatar" src="https://Leon2xiaowu.github.io/images/avatar.png?v=1560867619738" alt="">
  </a>
  <h1 class="site-title">
    普通程序员的博客
  </h1>
  <p class="site-description">
    Do not, for one repulse, forgo the purpose that you resolved to effort.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
               ES6学习笔记-Set和Map数据结构
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2016-12-17 ·
              </time>
              
                <a href="https://Leon2xiaowu.github.io/tag/JHRU9zkub" class="post-tag">
                  # Javascript
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://Leon2xiaowu.github.io/post-images/es6-xue-xi-bi-ji-set-he-map-shu-ju-jie-gou.jpg')">
              </div>
            
            <div class="post-content">
              <blockquote>
<p>无论在任何编程语言中，数据结构都是极其重要的基础，采用正确的数据结构甚至可以直接影响开发者的开发效效率</p>
</blockquote>
<h2 id="原有的数据结构">原有的数据结构</h2>
<p>​	在ECMAScript中，定义了以下几种数据结构，其中分为值类型(Primitive Type)、引用类型(Reference Type)</p>
<blockquote>
<p>值类型数据结构：</p>
</blockquote>
<ul>
<li>String - 字符串</li>
<li>Number - 数值</li>
<li>Boolean - 布尔</li>
<li>Null  - 空值</li>
<li>Undefined - 未定义值</li>
</ul>
<blockquote>
<p>引用类型数据结构：</p>
</blockquote>
<ul>
<li>Object - 对象</li>
<li>Array - 数组</li>
<li>RegExp - 正则表达式</li>
<li>Data - 日期</li>
<li>Error - 错误</li>
</ul>
<p>在严格意义上来说、引用类型只有Object一种。因为Array、Data等类型都是派生于Object的子类</p>
<h2 id="es6中新增的数据结构">ES6中新增的数据结构</h2>
<h3 id="set集合">Set集合</h3>
<p>​	在ECMAScript中，Array表示一系列元素的有序集合，每一个元素都带有一个自然数作为下标表示此元素的位置。但在很多情况下我们可能并不关心集合的顺序，甚至需要一个无序集合，在ES6之前这一直是一块空缺，直到TC-39将无序集合(Set)加入到ECMAScript中从而得以完善。</p>
<h4 id="使用语法">使用语法</h4>
<p>Set无法像数组一样通过&quot;[]&quot;语法直接生成，需要使用新建对象的方法来创建;在创建的时候我们也可以直接使用一个数组对象作为该集合对象的初始元素。</p>
<pre><code class="language-javascript">const set = new Set()、
//使用数组对Set元素进行初始化
const set = new Set(['a','b','c'])
</code></pre>
<h4 id="操作方法">操作方法</h4>
<p>由于现在没有直接的语法糖支持集合、所以对集合的操作都要通过集合对象来实现</p>
<ul>
<li>set.add(value)  ——  添加元素到集合内</li>
<li>set.delete(value)  ——  删除集合内的指定元素</li>
<li>set.has(value)  ——  判断集合内有无指定元素</li>
<li>set.clear()  ——  清空集合内的所有元素</li>
<li>set.forEach(callbackFn[, context])  ——  遍历集合内的元素、传入一个回调函数</li>
</ul>
<h4 id="数组与集合的区别">数组与集合的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">数组(Array)</th>
<th style="text-align:center">集合(Set)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">元素列表</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">无序</td>
</tr>
<tr>
<td style="text-align:center">元素可重复性</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不可重复</td>
</tr>
</tbody>
</table>
<blockquote>
<p>因为集合是无序的，所以不能像数组一样通过下标获取元素；但由于集合是可迭代的对象，所以可以使用ES6中的for of 对集合进行迭代，当然使用forEach也是可行的。</p>
</blockquote>
<blockquote>
<p>集合的不可重复性</p>
</blockquote>
<pre><code class="language-javascript">let set = new Set()
set.add('joker')
//重复的元素将无法加入集合中
set.add('joker')
set.add('joker1')
console.log(set)	//=&gt; Set只会包含‘joker’和‘joker1’两个元素
</code></pre>
<h3 id="map映射类型">Map映射类型</h3>
<blockquote>
<p>映射类型有很多种称呼，例如Map、Hash等，ECMAScript中的Object在结构上也属于映射类型。映射类型在计算机科学中的定义为<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a>，关联数组的定义是由若干个键值对组成的集合，每个键(Key)都是唯一的</p>
</blockquote>
<h4 id="使用语法-2">使用语法</h4>
<p>和Set一样Map也不能通过&quot;{}&quot;语法来直接创建，需要创建一个实例；创建实例的时候可以通过传入一个二维数组，Map根据数组的顺序对实例进行初始化，如果有重复的键则会按照FIFO(First In First Out)规则，以最后一个处理的Key最终值。</p>
<pre><code class="language-javascript">const map = new Map()
//通过传入一个二维数组进行初始化
const map = new Map([['a',1],['b',2]])
</code></pre>
<h4 id="操作方法-2">操作方法</h4>
<ul>
<li>map.set(key, value)		//添加键值对到map中
<ul>
<li>map.get(key)                       //获取指定key的value</li>
</ul>
</li>
<li>map.delete(key)                   //从map中移除指定key的键值对</li>
<li>map.clear()                           //清空map中的所有键值对</li>
<li>map.entries()                       //将map的键值对以二维数组的形式返回</li>
<li>map.has(key)                       //判断map中是否存在指定key的键值对</li>
<li>map.keys()                           //返回map中的所有键(key)作为一个可迭代对象</li>
<li>map.values()                       //返回map中的所有值(value)作为一个可迭代对象</li>
<li>map.size                              //map映射中所有键值对的数量</li>
</ul>
<h4 id="遍历映射对象中的键值对">遍历映射对象中的键值对</h4>
<p>由于映射对象是关联数组的一种实现，所以映射对象也同样是一种可迭代的对象。可以通过for-of来对其键值对进行遍历，当然也可以用ForEach来进行遍历</p>
<pre><code class="language-javascript">const map =new Map([['name','狗娃'],['gender','男']])
for (const [key, value] of map){
  console.log(`${key}:${value}`)
}
</code></pre>
<h4 id="map映射类型和object的区别">Map映射类型和Object的区别</h4>
<p>Map和Object在很多方面都是相同的，Map比Object多了两个非常方便的地方</p>
<ol>
<li>可以使用任何对象作为键</li>
<li>通过size属性可以方便的知道键值对的数量</li>
</ol>
<blockquote>
<p>除了这点之外、映射对象和普通对象的区别还体现在JSON序列化结果中。</p>
</blockquote>
<p>Object的JSON序列化结果是标准的字面量形式，而映射对象的JSON处理结果是关联数组的形式表达。这仲序列化结果的意义在于通过网络等方式反馈了结果后，通过JSON.parse方法直接将解释结果传入Map构造函数中来得到 正确的映射对象。</p>
<pre><code class="language-javascript">const map = new Map()
map.set('name','admin')
map.set('pswd','admin')
const response = JSON.stringify(map)
// .... 对数据进行处理...服务器返回结果到response
const resultMap = new Map(JSON.parse(response))
resultMap.get('name')	
</code></pre>
<h2 id="weakset-和-weakmap">WeakSet 和 WeakMap</h2>
<p>Weak类型的数据似乎是可以被用来保证内存安全，他们的键值对只能是引用类型，简单的值类型将无法加入其中。
WeakSet有以下三个特性</p>
<ol>
<li>不能包含值类型的元素，否则会抛出TypeError</li>
<li>不能包含无引用的对象，否则会自动清出集合</li>
</ol>
<blockquote>
<p>也就是说当WeakSet中任一元素的引用被全部解除后，该元素就会被移出集合</p>
</blockquote>
<ol start="3">
<li>无法被探知大小，也无法被探知其中包含的元素</li>
</ol>
<p>WeakMap和WeakSet很类似，只不过是WeakMap的键会被检查引用</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Leon2xiaowu.github.io/post/javascript-zhong-de-this">
              <h3 class="post-title">
                 JavaScript中的This
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://Leon2xiaowu.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
